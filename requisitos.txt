Objetivo: PicPay Simplificado
O PicPay Simplificado é uma plataforma de pagamentos simplificada. Nela é possível depositar e realizar transferências de dinheiro entre usuários. Temos 2 tipos de usuários, os comuns e lojistas, ambos têm carteira com dinheiro e realizam transferências entre eles.


Usuários podem enviar dinheiro (efetuar transferência) para lojistas e entre usuários;

Lojistas só recebem transferências, não enviam dinheiro para ninguém;

Validar se o usuário tem saldo antes da transferência;

Antes de finalizar a transferência, deve-se consultar um serviço autorizador externo, use este mock para simular (https://run.mocky.io/v3/5794d450-d2e2-4412-8131-73d0293ac1cc);

A operação de transferência deve ser uma transação (ou seja, revertida em qualquer caso de inconsistência) e o dinheiro deve voltar para a carteira do usuário que envia;

No recebimento de pagamento, o usuário ou lojista precisa receber notificação (envio de email, sms) enviada por um serviço de terceiro e eventualmente este serviço pode estar indisponível/instável. Use este mock para simular o envio (https://run.mocky.io/v3/54dc2cf1-3add-45b5-b5a9-6bf7e7f1f4a6);

Este serviço deve ser RESTFul.

Endpoint de transferência
Você pode implementar o que achar conveniente, porém vamos nos atentar somente ao fluxo de transferência entre dois usuários. A implementação deve seguir o contrato abaixo.

POST /transfer
Content-Type: application/json

{
  "value": 100.0,
  "payer": 4,
  "payee": 15
}

Pontos importantes

Habilidades básicas de criação de projetos backend:

Conhecimentos sobre REST
Uso do Git
Capacidade analítica
Apresentação de código limpo e organizado
Conhecimentos intermediários de construção de projetos manuteníveis:

Aderência a recomendações de implementação como as PSRs
Aplicação e conhecimentos de SOLID
Identificação e aplicação de Design Patterns
Noções de funcionamento e uso de Cache
Conhecimentos sobre conceitos de containers (Docker, Podman etc)
Documentação e descrição de funcionalidades e manuseio do projeto
Implementação e conhecimentos sobre testes de unidade e integração
Identificar e propor melhorias
Boas noções de bancos de dados relacionais
Aptidões para criar e manter aplicações de alta qualidade:

Aplicação de conhecimentos de observabilidade
Utlização de CI para rodar testes e análises estáticas
Conhecimentos sobre bancos de dados não-relacionais
Aplicação de arquiteturas (CQRS, Event-sourcing, Microsserviços, Monolito modular)
Uso e implementação de mensageria
Noções de escalabilidade
Boas habilidades na aplicação do conhecimento do negócio no software
Implementação margeada por ferramentas de qualidade (análise estática, PHPMD, PHPStan, PHP-CS-Fixer etc)
Noções de PHP assíncrono

Diferenciais
Uso de Docker
Uma cobertura de testes consistente
Uso de Design Patterns
Documentação
Proposta de melhoria na arquitetura
Ser consistente e saber argumentar suas escolhas
Apresentar soluções que domina
Modelagem de Dados
Manutenibilidade do Código
Tratamento de erros
Cuidado com itens de segurança
Arquitetura (estruturar o pensamento antes de escrever)
Carinho em desacoplar componentes (outras camadas, service, repository)



Domínio (Entities e Use Cases): Aqui ficariam as regras de negócio. Você teria entidades para User (com subclasses ou tipos para usuários comuns e lojistas) e Transaction. Os casos de uso poderiam incluir RegisterUser, TransferMoney, NotifyUser, etc.

Ports: Você teria ports para os diferentes tipos de interação que sua aplicação precisa suportar. Por exemplo, você poderia ter um UserRepository para gerenciar a persistência de usuários, um TransactionRepository para gerenciar a persistência de transações, e um NotificationService para enviar notificações.

Adapters: Aqui ficariam as implementações específicas dos seus ports. Por exemplo, você poderia ter um JpaUserRepository e um JpaTransactionRepository que usam JPA para persistir usuários e transações em um banco de dados relacional. Para o NotificationService, você poderia ter um EmailNotificationService que usa um serviço de email para enviar notificações.

Aplicação: Esta camada orquestra o fluxo de controle entre os ports e os adapters. Por exemplo, o caso de uso TransferMoney poderia usar o UserRepository para buscar os usuários envolvidos, verificar se a transferência é válida, usar o TransactionRepository para registrar a transferência, e então usar o NotificationService para notificar os usuários.

Infraestrutura: Aqui ficariam coisas como o banco de dados, o servidor web, qualquer serviço de fila de mensagens que você esteja usando, etc.

Entradas e Saídas: As entradas seriam coisas como o endpoint REST /transfer mencionado nos requisitos. As saídas seriam coisas como o banco de dados e o serviço de notificação.